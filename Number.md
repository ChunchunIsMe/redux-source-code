## 怪异的Number
对于 JavaScript 开发者来说，肯定遇到过 js 处理数字上的奇怪现象，比如
```
0.1 + 0.2 // 0.30000000000000004
0.1 + 1 - 1 // 0.10000000000000009
0.1 * 0.2 // 0.020000000000000004
2 ** 53 // 9007199254740992
2 ** 53 + 1 // 9007199254740992
2 ** 53 +3 // 9007199254740996
```
### JavaScript 是怎样编码 Number 的
JavaScript 中的数字，不管是整数、小数、分数，还是正数、负数，都是用 8 个字节（64位） 来存储的。

一个数字在内存中占用 64 位，储存方式如下：

  0-51：分数部分（52位）

  52-62：指数部分（11位）

  63：符号位（1位：0表示正数，1表示负数）

符号位很好理解,用于指明是正数还是负数，且只有1位、两种情况（0表示正数，1表示负数）。

其他两部分是分数部分和指数部分，用于计算一个数的绝对值

#### 1.1 绝对值计算公式
```
// 这里公式的左边 1.f 是二进制, 右边 2 ** (e - 1023) 是十进制

1: abs = 1.f * (2 ** (e - 1023))    // 0 < e < 2047
2: abs = 0.f * (2 ** (e - 1022))    // e = 0, f > 0
3: abs = 0                          // e = 0, f = 0
4: abs = NaN                        // e = 2047, f > 0
5: abs = infinity                   // e = 2047, f = 0
```
说明：
  这个公式是二进制的算法公式，结果用abs表示，分数部分用 f 表示，指数部分用 e 表示

  因为分数部分占 52 位 所以 f 的取值范围是 0 (000...00,共52个0) 到 (2 ** 52) - 1 (111...111, 共52个1) 

  因为指数部分占 11 为 所以 e 的取值范围为 0 (00000000000) 到 2047 (11111111111)

我看可以看出:
```
1 的储存方式: 1.00 * 2 ** (1023 - 1023) (f = 0000..., e = 1023)
2 的储存方式: 1.00 * 2 ** (1024 - 1023) (f = 0000..., e = 1024)
9 的储存方式: 1.001 * 2 ** (1026 - 1023) (f = 000..., e = 1026)   // 1001 是二进制，转换成 10 进制是 9
0.5 的储存方式: 1.00 * 2 ** (1022 - 1023) (f = 000..., e = 1022)
```
#### 1.2绝对值的取值范围与边界
##### 0 < e < 2047
当 `0 < e < 2047` 时, 取值范围为: `f = 0, e = 1`到`f = 11...11( 52 个 1 ), e = 2046`

abs的范围为 1.0 * 2 ** -1022 到 1.11..11(小数点后有52个1) * 2 ** 1023

其最大值约等于 2 ** 1024 - 1 这个就是`Number.MAX_VALUE`的值，`js`所能表示的最大值
##### e = 0, f > 0
当 `e = 0, f > 0`时, 取值范围为: `f = 00...001, e = 0` 到 `f = 1111...1111, e = 0`

即： 0.000...01 * 2 ** -1022 到 0.1111...111 * 2 ** -1022

即： 2 ** -1074 到 ~= 2 ** -1022

而 2 ** -1074 就是 js 所能表示的最小值 (绝对值) 
##### e = 0, f = 0 0
##### e = 2047, f > 0 NaN
##### e = 2047, f = 0 infinity
#### 绝对值的最大安全值
从上面可以看出 8 个字节存储的最大数值是 `Number.MAX_VALUE`的值

但是这个值是不安全的: 从 `1` 到 `Number.MAX_VALUE` 中间的数字并不连续，而是离散的

比如 1.111..1111(小数点后52个1) * 2 ** 52 是 1111...111 (53个1) 

但是如果 1.11..11(小数点后52个1) * 2 ** 53 是 1111...1110 (53个1) JS无法表示 1111...1111 ( 54 个 1 ) 原因就是 f 最多 53 位

所以 JS 的最大安全值 `Number.MAX_SAFE_INTEGER` 是 2 ** 53 - 1
#### 小数的储存方式与计算
因为小数转换成二进制的方法是：如：0.75
```
0.75 = 1 * 2 ** -1 + 1 ** 2 ** -2
```
0.75 的二进制就是 0.11

有时候二进制小数会出现无限循环的情况，所以小数中，除了满足 `m / (2 ** n)` (`m, n`都是整数) 的小数可以用完整的 2 进制表示之外，其他的都不能用完整的2进制表示，只能无限的逼近一个 2 进制小数。

(注: `[2]`表示二进制)
```
0.5 = 1 / 2 = [2]0.1
0.875 = 7 / 8 = 1 * 2 ** -1 + 1 ** 2 ** -2 + 1 ** 2 ** -3 = 0.111
```
#### 奇怪的现象
到现在我们也可以解释各种js的数字奇怪的现象了，原因即是f超过了52位
#### API
** 运算符 其实就是幂乘运算符，原来有个方法 Math.pow(base, exponent)一样可以实现同样的效果